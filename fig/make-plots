#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import collections
import functools
import inspect
import pickle
import sys

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.ticker as tick
import seaborn as sns


aspect = 1/1.618
resolution = 72.27
columnwidth = 246/resolution
textwidth = 510/resolution
textiny, texsmall, texnormal = 8., 9.25, 10.
offblack = '#262626'

sns.set(
    context='paper',
    style='white',
    font='CMU Serif',
    rc={
        'font.size': texsmall,
        'legend.fontsize': texsmall,
        'axes.labelsize': texsmall,
        'axes.titlesize': texsmall,
        'xtick.labelsize': textiny,
        'ytick.labelsize': textiny,
        'lines.linewidth': .9,
        'patch.linewidth': .9,
        'axes.linewidth': .5,
        'xtick.major.width': .5,
        'ytick.major.width': .5,
        'text.color': offblack,
        'axes.edgecolor': offblack,
        'axes.labelcolor': offblack,
        'xtick.color': offblack,
        'ytick.color': offblack,
        'xtick.direction': 'in',
        'ytick.direction': 'in',
        'xtick.major.pad': 2.0,
        'ytick.major.pad': 2.0,
    }
)


class Results(dict):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.__dict__ = self

observables = (
    ('mult', r'$\langle N_\mathrm{ch} \rangle$'),
    ('v2', r'$v_2\{2\}$'),
    ('v3', r'$v_3\{2\}$')
)

ic_data = collections.OrderedDict((
    ('glb', Results(
        display_name='Glauber',
        labels=('Normalization', r'$\alpha$',
                r'$\tau_0$', r'$\eta/s$', r'$\tau_\Pi$'),
        initial_params=(56.8, 0.118, 0.6, 0.08, 0.5)
    )),
    ('kln', Results(
        display_name='KLN',
        labels=('Normalization', r'$\lambda$',
                r'$\tau_0$', r'$\eta/s$', r'$\tau_\Pi$'),
        initial_params=(9.92, 0.138, 0.6, 0.08, 0.5)
    ))
))

for ic, data in ic_data.items():
    with open('../mcmc/{}.pkl'.format(ic), 'rb') as f:
        # pca, training_samplers, kernel_pars
        # cal_chain, cal_samples, cal_logprob
        # validation
        data.update(pickle.load(f))
    with open('../data/model/{}.pkl'.format(ic), 'rb') as f:
        # cent, design, mult, v2, v3
        data.update(pickle.load(f))

experiment = 'alice'

with open('../data/exp/{}.pkl'.format(experiment), 'rb') as f:
    exp = pickle.load(f)


plotfns = {}


def _register_plotfn(f):
    name = f.__name__

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        print(name)
        f(*args, **kwargs)
        plt.savefig(name + '.pdf')
        plt.close()

    plotfns[name] = wrapper


def plotfn(f):
    p = tuple(inspect.signature(f).parameters.values())
    if (
            len(p) >= 2 and
            p[0].name == 'ic' and
            p[0].default is inspect.Parameter.empty and
            p[1].name == 'data'
    ):
        for ic, data in ic_data.items():
            g = functools.partial(f, ic, data)
            g.__name__ = '_'.join((f.__name__, ic))
            _register_plotfn(g)
    else:
        _register_plotfn(f)


def nicehist(x, bins=50, cmap=plt.cm.Blues, **kwargs):
    counts, edges = np.histogram(x, bins=bins)
    middles = .5 * (edges[1:] + edges[:-1])
    color = cmap(.8)

    ax = plt.gca()
    ax.plot(middles, counts, color=color)
    ax.fill_between(middles, counts, color=color, alpha=.1)


def hist2d(*args, **kwargs):
    kwargs.pop('color', None)
    kwargs['cmin'] = 1
    plt.hist2d(*args, **kwargs)


def ciplot(x, y, bins=30, levels=(.68, .95, .99), **kwargs):
    colors = sns.color_palette('Blues_d', len(levels)+1)

    H, xedges, yedges = np.histogram2d(x, y, bins=bins)
    xmids = .5*(xedges[1:] + xedges[:-1])
    ymids = .5*(yedges[1:] + yedges[:-1])

    Hsorted = np.sort(H, axis=None)
    cs = Hsorted.cumsum()
    cs /= cs[-1]
    V = np.array([Hsorted[np.count_nonzero(cs <= 1.-i)] for i in levels])

    ax = plt.gca()
    ax.plot(np.median(x), np.median(y), 'o', color=offblack, ms=4)
    ax.contour(xmids, ymids, H.T, V, colors=colors)


@plotfn
def train(ic, data):
    samplers = data.training_samplers
    hyperlabels = (
        ['GP variance'] +
        [r'$\ell$ {}'.format('Norm' if p == 'Normalization' else p)
         for p in data.labels] +
        ['Noise']
    )

    npc = len(samplers)
    nhyper = len(hyperlabels)

    fig, axes = plt.subplots(nrows=npc, ncols=nhyper,
                             sharex='col', sharey='row',
                             figsize=(textwidth, .08*textwidth*aspect*nhyper))

    for n, (row, sampler) in enumerate(zip(axes, samplers)):
        for ax, chain, label in zip(row, sampler.flatchain.T, hyperlabels):
            if ax.is_first_col():
                ax.set_xlim(0, 3)
                ax.set_xticks(np.arange(4))
                ax.set_ylabel('PC {}'.format(n))
            else:
                ax.set_xlim(0, 1)
                ax.set_xticks((0., .5, 1.))
                ax.set_xticklabels(('0', '0.5', '1'))
            if ax.is_last_row():
                ax.set_xlabel(label)

            ax.xaxis.set_tick_params(length=2)
            ax.set_yticks([])

            ax.hist(chain, bins=20, range=ax.get_xlim(), histtype='step')

    sns.despine()
    fig.tight_layout(pad=0, h_pad=.2, w_pad=.2)


@plotfn
def cal_post(ic, data):
    chain = pd.DataFrame(data.cal_chain, columns=data.labels)

    cmap = plt.cm.Blues

    g = sns.PairGrid(chain, size=textwidth/chain.shape[1])
    g.map_diag(nicehist, bins=100, cmap=cmap)
    g.map_lower(hist2d, bins=50, cmap=cmap)
    g.map_upper(ciplot)

    for ax in g.axes.flat:
        prune = None if ax.is_first_col() else 'lower'
        for axis in ax.xaxis, ax.yaxis:
            axis.set_major_locator(tick.MaxNLocator(
                nbins=5, steps=(1, 2, 3, 5, 10), prune=prune))
            axis.set_tick_params(length=2)

    plt.gcf().subplots_adjust(
        left=.064, bottom=.047, right=.998, top=.998,
        wspace=.05, hspace=.05
    )


@plotfn
def prior_draws():
    nic = len(ic_data)
    nobs = len(observables)
    fig, axes = plt.subplots(nrows=nic, ncols=nobs, sharex='col',
                             figsize=(textwidth, nobs/nic*columnwidth*aspect))

    ylims = 6000., .15, .045

    for row, (ic, data) in zip(axes, ic_data.items()):
        row[0].set_ylabel(data.display_name)
        for ax, (obs, label), ymax in zip(row, observables, ylims):
            x = data['cent']
            for y in data[obs]:
                ax.plot(x, y, color='SkyBlue', alpha=.2, lw=.5)

            ax.errorbar(exp['cent'], exp[obs]['mean'], yerr=exp[obs]['sys'],
                        fmt='o', lw=.8, ms=2, capsize=0, color='.2')
            ax.yaxis.set_major_locator(tick.MaxNLocator(
                nbins=4, steps=(1, 2, 3, 5, 10)))

            ax.set_ylim(0, ymax)

            if ax.is_first_row():
                ax.set_title(label)
            else:
                ax.set_xlabel('Centrality %')
                ax.set_xlim(0, x.max() + .5)

    sns.despine()
    fig.tight_layout(pad=0, w_pad=.4)


@plotfn
def post_draws():
    nic = len(ic_data)
    nobs = len(observables)
    fig, axes = plt.subplots(nrows=nic, ncols=nobs, sharex='col',
                             figsize=(textwidth, nobs/nic*columnwidth*aspect))

    sample_idx = np.random.randint(0, ic_data['glb']['cal_chain'].shape[0],
                                   size=100)

    ylims = 3200., .12, .035

    for row, (ic, data) in zip(axes, ic_data.items()):
        row[0].set_ylabel(data.display_name)
        for ax, (obs, label), ymax in zip(row, observables, ylims):
            x = data['cent']
            samples = data.cal_samples[obs]
            for i in sample_idx:
                ax.plot(x, samples[i], color='SkyBlue', alpha=.2, lw=.5)

            ax.errorbar(exp['cent'], exp[obs]['mean'], yerr=exp[obs]['sys'],
                        fmt='o', lw=.8, ms=2, capsize=0, color='.2')
            ax.yaxis.set_major_locator(tick.MaxNLocator(
                nbins=4, steps=(1, 2, 3, 5, 10)))

            ax.set_ylim(0, ymax)

            if ax.is_first_row():
                ax.set_title(label)
            else:
                ax.set_xlabel('Centrality %')
                ax.set_xlim(0, x.max() + .5)

    sns.despine()
    fig.tight_layout(pad=0, w_pad=.4)


@plotfn
def validation(ic='glb'):
    predicted = ic_data[ic].validation

    with open('../data/model/{}-validation.pkl'.format(ic), 'rb') as f:
        actual = pickle.load(f)

    fig, axes = plt.subplots(ncols=3,
                             figsize=(textwidth, .55*aspect*textwidth))

    xylim = 5500., .12, .045
    xyticks = np.r_[0:5000:3j], np.r_[0:.12:5j], np.r_[0:.04:5j]

    for ax, (obs, label), lim, ticks in zip(axes, observables, xylim, xyticks):
        mean, std = (predicted[obs][i].T[::2] for i in ('mean', 'std'))
        act = actual[obs].T

        for c, m, e, a in zip(actual['cent'], mean, std, act):
            ax.errorbar(m, a, xerr=2*e,
                        fmt='o', ms=2.5, lw=.6, capsize=0, alpha=.75,
                        label=str(c), zorder=int(c))

        ax.set_aspect('equal')
        ax.set_xlim(0, lim)
        ax.set_ylim(0, lim)
        ax.plot(ax.get_xlim(), ax.get_ylim(),
                lw=.5, color='.5', alpha=.5, zorder=-10)

        ax.set_xticks(ticks)
        ax.set_yticks(ticks[1:])

        ax.set_xlabel('Predicted ' + label)

        if ax.is_first_col():
            ax.set_ylabel('Observed')
            ax.legend(loc='best')

    fig.tight_layout(pad=.4, w_pad=-.2)
    sns.despine()


def main():
    if len(sys.argv) > 1:
        for a in sys.argv[1:]:
            plotfns[a.rstrip('.pdf')]()
    else:
        for fn in plotfns.values():
            fn()


if __name__ == "__main__":
    main()
