#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import itertools
import functools
import pickle

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.ticker as tick
import seaborn as sns


aspect = 1/1.618
resolution = 72.27
columnwidth = 246/resolution
textwidth = 510/resolution
textiny, texsmall, texnormal = 8., 9.25, 10.
offblack = '#262626'

sns.set(
    context='paper',
    style='white',
    font='CMU Serif',
    rc={
        'font.size': texsmall,
        'legend.fontsize': texsmall,
        'axes.labelsize': texsmall,
        'axes.titlesize': texsmall,
        'xtick.labelsize': textiny,
        'ytick.labelsize': textiny,
        'lines.linewidth': .9,
        'patch.linewidth': .9,
        'axes.linewidth': .5,
        'text.color': offblack,
        'axes.edgecolor': offblack,
        'axes.labelcolor': offblack,
        'xtick.color': offblack,
        'ytick.color': offblack,
        'xtick.major.pad': 2.0,
        'ytick.major.pad': 2.0,
    }
)


def plotfn(f):
    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        print(f.__name__, *args)
        f(*args, **kwargs)
        plt.savefig('_'.join((f.__name__, args[0])) + '.pdf')
        plt.close()
    return wrapper


def _histstep(*args, **kwargs):
    kwargs['histtype'] = 'stepfilled'
    kwargs.pop('color', None)
    palette = kwargs.pop('palette', 'Blues')
    cmap = getattr(plt.cm, palette)
    kwargs['color'] = cmap(.2)
    kwargs['edgecolor'] = cmap(.95)
    return plt.hist(*args, **kwargs)


def _hist2d(*args, **kwargs):
    kwargs.pop('color', None)
    return plt.hist2d(*args, **kwargs)


def ciplot(x, y, **kwargs):
    bins = kwargs.pop('bins', 30)
    levels = kwargs.pop('levels', [.68, .95, .99])
    kwargs['colors'] = sns.color_palette('Blues_d', len(levels)+1)

    H, xedges, yedges = np.histogram2d(x, y, bins=bins)
    xmids = .5*(xedges[1:] + xedges[:-1])
    ymids = .5*(yedges[1:] + yedges[:-1])

    Hsorted = np.sort(H, axis=None)
    cs = Hsorted.cumsum()
    cs /= cs[-1]
    V = np.array([Hsorted[np.count_nonzero(cs <= 1.-i)] for i in levels])

    plt.plot(np.median(x), np.median(y), 'o', color=offblack, ms=4)

    return plt.contour(xmids, ymids, H.T, V, **kwargs)


@plotfn
def training_posterior(ic, labels, **kwargs):
    hyperlabels = itertools.chain(
        ['GP variance'],
        (r'$\ell$ {}'.format('Norm' if p == 'Normalization' else p)
         for p in labels),
        ['Noise'])

    with open('../mcmc/{}.pkl'.format(ic), 'rb') as f:
        results = pickle.load(f)
        chain = pd.DataFrame(results['training_samplers'][0].flatchain,
                             columns=hyperlabels)
        kernel_pars = results['kernel_pars'][0]
        del results

    g = sns.PairGrid(chain, size=textwidth/chain.shape[1])
    g.map_diag(_histstep, bins=40)
    g.map_lower(_hist2d, bins=20, cmap='Blues')

    for n, p in enumerate(kernel_pars):
        g.axes[n][n].axvline(p, color='black')

    for ax in g.axes.flat:
        for axis in 'xaxis', 'yaxis':
            getattr(ax, axis).set_major_locator(
                tick.MaxNLocator(4, prune='both'))
            ax.ticklabel_format(scilimits=(-3, 3))

    plt.gcf().subplots_adjust(
        left=.064, bottom=.047, right=.998, top=.998,
        wspace=.05, hspace=.05
    )


@plotfn
def calibration_posterior(ic, labels, **kwargs):
    with open('../mcmc/{}.pkl'.format(ic), 'rb') as f:
        chain = pd.DataFrame(pickle.load(f)['cal_chain'], columns=labels)

    palette = 'Blues'

    g = sns.PairGrid(chain, size=textwidth/chain.shape[1], palette=palette)
    g.map_diag(_histstep, bins=100, palette=palette)
    g.map_lower(_hist2d, bins=50, cmap=palette)
    g.map_upper(ciplot)

    for ax in g.axes.flat:
        for axis in 'xaxis', 'yaxis':
            getattr(ax, axis).set_major_locator(
                tick.MaxNLocator(4, prune='both'))

    plt.gcf().subplots_adjust(
        left=.064, bottom=.047, right=.998, top=.998,
        wspace=.05, hspace=.05
    )


@plotfn
def prior_draws(ic, **kwargs):
    with open('../data/model/{}.pkl'.format(ic), 'rb') as f:
        model = pickle.load(f)
    with open('../data/exp/{}.pkl'.format(experiment), 'rb') as f:
        exp = pickle.load(f)

    fig, axes = plt.subplots(ncols=3, figsize=(textwidth, columnwidth*aspect))

    for ax, (obs, label) in zip(axes, observables):
        c = model['cent']
        for m in model[obs]:
            ax.plot(c, m, color='SkyBlue', alpha=.2, lw=.5)

        ax.errorbar(exp['cent'], exp[obs]['mean'], yerr=exp[obs]['sys'],
                    fmt='o', lw=.8, ms=2, capsize=0, color='.2')

        ax.set_xlabel('Centrality %')
        ax.set_xlim(0, 55)
        ax.set_ylim(ymin=0)

        ax.annotate(label, (.5, .98), xycoords='axes fraction',
                    ha='center', va='top')

    sns.despine()
    plt.tight_layout(pad=0)


@plotfn
def posterior_draws(ic, **kwargs):
    with open('../data/model/{}.pkl'.format(ic), 'rb') as f:
        cent = pickle.load(f)['cent']
    with open('../data/exp/{}.pkl'.format(experiment), 'rb') as f:
        exp = pickle.load(f)
    with open('../mcmc/{}.pkl'.format(ic), 'rb') as f:
        cal_samples = pickle.load(f)['cal_samples']

    sample_idx = np.random.randint(0, cal_samples['mult'].shape[0], size=100)

    fig, axes = plt.subplots(ncols=3, figsize=(textwidth, columnwidth*aspect))

    for ax, (obs, label) in zip(axes, observables):
        samples = cal_samples[obs]

        for i in sample_idx:
            ax.plot(cent, samples[i], color='SkyBlue', alpha=.2, lw=.5)

        ax.errorbar(exp['cent'], exp[obs]['mean'], yerr=exp[obs]['sys'],
                    fmt='o', lw=.8, ms=2, capsize=0, color='.2')

        ax.set_xlabel('Centrality %')
        ax.set_xlim(0, 55)
        ax.set_ylim(ymin=0)

        ax.annotate(label, (.5, .9 if obs == 'mult' else .5),
                    xycoords='axes fraction',
                    ha='center', va='top')

    sns.despine()
    plt.tight_layout(pad=0)


@plotfn
def validation(ic, **kwargs):
    with open('../mcmc/{}.pkl'.format(ic), 'rb') as f:
        predicted = pickle.load(f)['validation']
    with open('../data/model/{}-validation.pkl'.format(ic), 'rb') as f:
        actual = pickle.load(f)

    fig, axes = plt.subplots(ncols=3,
                             figsize=(textwidth, .55*aspect*textwidth))

    xylim = 5500., .12, .045
    xyticks = np.r_[0:5000:3j], np.r_[0:.12:5j], np.r_[0:.04:5j]

    for ax, (obs, label), lim, ticks in zip(axes, observables, xylim, xyticks):
        mean, std = (predicted[obs][i].T[::2] for i in ('mean', 'std'))
        act = actual[obs].T

        for c, m, e, a in zip(actual['cent'], mean, std, act):
            ax.errorbar(m, a, xerr=2*e,
                        fmt='o', ms=2.5, lw=.6, capsize=0, alpha=.75,
                        label=str(c), zorder=int(c))

        ax.set_aspect('equal')
        ax.set_xlim(0, lim)
        ax.set_ylim(0, lim)
        ax.plot(ax.get_xlim(), ax.get_ylim(),
                lw=.5, color='.5', alpha=.5, zorder=-10)

        ax.set_xticks(ticks)
        ax.set_yticks(ticks[1:])

        ax.set_xlabel('Predicted ' + label)

        if ax.is_first_col():
            ax.set_ylabel('Observed ')
            ax.legend(loc='best')

    plt.tight_layout(pad=.4, w_pad=-.2)
    sns.despine(fig)


params = {
    'glb': {
        'labels': ('Normalization', r'$\alpha$',
                   r'$\tau_0$', r'$\eta/s$', r'$\tau_\Pi$'),
        'prior': (56.8, 0.118, 0.6, 0.08, 0.5)
    },
    'kln': {
        'labels': ('Normalization', r'$\lambda$',
                   r'$\tau_0$', r'$\eta/s$', r'$\tau_\Pi$'),
        'prior': (9.92, 0.138, 0.6, 0.08, 0.5)
    }
}
experiment = 'alice'
observables = (
    ('mult', r'$\langle N_\mathrm{ch} \rangle$'),
    ('v2', r'$v_2\{2\}$'),
    ('v3', r'$v_3\{2\}$')
)


if __name__ == "__main__":
    for ic, kwargs in params.items():
        training_posterior(ic, **kwargs)
        calibration_posterior(ic, **kwargs)
        prior_draws(ic, **kwargs)
        posterior_draws(ic, **kwargs)

    validation('glb', **params['glb'])
